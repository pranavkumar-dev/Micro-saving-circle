"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var Se=require("@walletconnect/sign-client"),h=require("@walletconnect/utils"),G=require("@walletconnect/logger"),N=require("@walletconnect/jsonrpc-utils"),W=require("@walletconnect/jsonrpc-provider"),J=require("@walletconnect/jsonrpc-http-connection"),$e=require("events");function q(t){return t&&typeof t=="object"&&"default"in t?t:{default:t}}var Ae=q(Se),Ee=q(J),je=q($e);const Y="error",Ce="wss://relay.walletconnect.org",Ne="wc",qe="universal_provider",I=`${Ne}@2:${qe}:`,X="https://rpc.walletconnect.org/v1/",k="generic",_e=`${X}bundler`,v="call_status",Re=86400,_={DEFAULT_CHAIN_CHANGED:"default_chain_changed"};function R(t){return t==null||typeof t!="object"&&typeof t!="function"}function Q(t){return Object.getOwnPropertySymbols(t).filter(e=>Object.prototype.propertyIsEnumerable.call(t,e))}function Z(t){return t==null?t===void 0?"[object Undefined]":"[object Null]":Object.prototype.toString.call(t)}const De="[object RegExp]",T="[object String]",ee="[object Number]",te="[object Boolean]",se="[object Arguments]",xe="[object Symbol]",Fe="[object Date]",Ue="[object Map]",He="[object Set]",Le="[object Array]",Be="[object ArrayBuffer]",Me="[object Object]",Ke="[object DataView]",Ve="[object Uint8Array]",ze="[object Uint8ClampedArray]",Ge="[object Uint16Array]",We="[object Uint32Array]",Je="[object Int8Array]",Ye="[object Int16Array]",Xe="[object Int32Array]",ke="[object Float32Array]",Qe="[object Float64Array]";function D(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)}function Ze(t,e){return w(t,void 0,t,new Map,e)}function w(t,e,s,i=new Map,n=void 0){const a=n?.(t,e,s,i);if(a!=null)return a;if(R(t))return t;if(i.has(t))return i.get(t);if(Array.isArray(t)){const r=new Array(t.length);i.set(t,r);for(let c=0;c<t.length;c++)r[c]=w(t[c],c,s,i,n);return Object.hasOwn(t,"index")&&(r.index=t.index),Object.hasOwn(t,"input")&&(r.input=t.input),r}if(t instanceof Date)return new Date(t.getTime());if(t instanceof RegExp){const r=new RegExp(t.source,t.flags);return r.lastIndex=t.lastIndex,r}if(t instanceof Map){const r=new Map;i.set(t,r);for(const[c,o]of t)r.set(c,w(o,c,s,i,n));return r}if(t instanceof Set){const r=new Set;i.set(t,r);for(const c of t)r.add(w(c,void 0,s,i,n));return r}if(typeof Buffer<"u"&&Buffer.isBuffer(t))return t.subarray();if(D(t)){const r=new(Object.getPrototypeOf(t)).constructor(t.length);i.set(t,r);for(let c=0;c<t.length;c++)r[c]=w(t[c],c,s,i,n);return r}if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer)return t.slice(0);if(t instanceof DataView){const r=new DataView(t.buffer.slice(0),t.byteOffset,t.byteLength);return i.set(t,r),g(r,t,s,i,n),r}if(typeof File<"u"&&t instanceof File){const r=new File([t],t.name,{type:t.type});return i.set(t,r),g(r,t,s,i,n),r}if(t instanceof Blob){const r=new Blob([t],{type:t.type});return i.set(t,r),g(r,t,s,i,n),r}if(t instanceof Error){const r=new t.constructor;return i.set(t,r),r.message=t.message,r.name=t.name,r.stack=t.stack,r.cause=t.cause,g(r,t,s,i,n),r}if(typeof t=="object"&&Te(t)){const r=Object.create(Object.getPrototypeOf(t));return i.set(t,r),g(r,t,s,i,n),r}return t}function g(t,e,s=t,i,n){const a=[...Object.keys(e),...Q(e)];for(let r=0;r<a.length;r++){const c=a[r],o=Object.getOwnPropertyDescriptor(t,c);(o==null||o.writable)&&(t[c]=w(e[c],c,s,i,n))}}function Te(t){switch(Z(t)){case se:case Le:case Be:case Ke:case te:case Fe:case ke:case Qe:case Je:case Ye:case Xe:case Ue:case ee:case Me:case De:case He:case T:case xe:case Ve:case ze:case Ge:case We:return!0;default:return!1}}function et(t,e){return Ze(t,(s,i,n,a)=>{const r=e?.(s,i,n,a);if(r!=null)return r;if(typeof t=="object")switch(Object.prototype.toString.call(t)){case ee:case T:case te:{const c=new t.constructor(t?.valueOf());return g(c,t),c}case se:{const c={};return g(c,t),c.length=t.length,c[Symbol.iterator]=t[Symbol.iterator],c}default:return}})}function ie(t){return et(t)}function re(t){return t!==null&&typeof t=="object"&&Z(t)==="[object Arguments]"}function ne(t){return typeof t=="object"&&t!==null}function tt(){}function st(t){return D(t)}function it(t){if(typeof t!="object"||t==null)return!1;if(Object.getPrototypeOf(t)===null)return!0;if(Object.prototype.toString.call(t)!=="[object Object]"){const s=t[Symbol.toStringTag];return s==null||!Object.getOwnPropertyDescriptor(t,Symbol.toStringTag)?.writable?!1:t.toString()===`[object ${s}]`}let e=t;for(;Object.getPrototypeOf(e)!==null;)e=Object.getPrototypeOf(e);return Object.getPrototypeOf(t)===e}function rt(t){if(R(t))return t;if(Array.isArray(t)||D(t)||t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer)return t.slice(0);const e=Object.getPrototypeOf(t),s=e.constructor;if(t instanceof Date||t instanceof Map||t instanceof Set)return new s(t);if(t instanceof RegExp){const i=new s(t);return i.lastIndex=t.lastIndex,i}if(t instanceof DataView)return new s(t.buffer.slice(0));if(t instanceof Error){const i=new s(t.message);return i.stack=t.stack,i.name=t.name,i.cause=t.cause,i}if(typeof File<"u"&&t instanceof File)return new s([t],t.name,{type:t.type,lastModified:t.lastModified});if(typeof t=="object"){const i=Object.create(e);return Object.assign(i,t)}return t}function nt(t,...e){const s=e.slice(0,-1),i=e[e.length-1];let n=t;for(let a=0;a<s.length;a++){const r=s[a];n=S(n,r,i,new Map)}return n}function S(t,e,s,i){if(R(t)&&(t=Object(t)),e==null||typeof e!="object")return t;if(i.has(e))return rt(i.get(e));if(i.set(e,t),Array.isArray(e)){e=e.slice();for(let a=0;a<e.length;a++)e[a]=e[a]??void 0}const n=[...Object.keys(e),...Q(e)];for(let a=0;a<n.length;a++){const r=n[a];let c=e[r],o=t[r];if(re(c)&&(c={...c}),re(o)&&(o={...o}),typeof Buffer<"u"&&Buffer.isBuffer(c)&&(c=ie(c)),Array.isArray(c))if(typeof o=="object"&&o!=null){const u=[],p=Reflect.ownKeys(o);for(let m=0;m<p.length;m++){const d=p[m];u[d]=o[d]}o=u}else o=[];const l=s(o,c,r,t,e,i);l!=null?t[r]=l:Array.isArray(c)||ne(o)&&ne(c)?t[r]=S(o,c,s,i):o==null&&it(c)?t[r]=S({},c,s,i):o==null&&st(c)?t[r]=ie(c):(o===void 0||c!==void 0)&&(t[r]=c)}return t}function at(t,...e){return nt(t,...e,tt)}var ct=Object.defineProperty,ot=Object.defineProperties,pt=Object.getOwnPropertyDescriptors,ae=Object.getOwnPropertySymbols,ht=Object.prototype.hasOwnProperty,lt=Object.prototype.propertyIsEnumerable,ce=(t,e,s)=>e in t?ct(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,$=(t,e)=>{for(var s in e||(e={}))ht.call(e,s)&&ce(t,s,e[s]);if(ae)for(var s of ae(e))lt.call(e,s)&&ce(t,s,e[s]);return t},ut=(t,e)=>ot(t,pt(e));function oe(t,e,s){var i;const n=h.parseChainId(t);return((i=e.rpcMap)==null?void 0:i[n.reference])||`${X}?chainId=${n.namespace}:${n.reference}&projectId=${s}`}function dt(t){return t.includes(":")?t.split(":")[1]:t}function pe(t){return t.map(e=>`${e.split(":")[0]}:${e.split(":")[1]}`)}function ft(t,e){const s=Object.keys(e.namespaces).filter(n=>n.includes(t));if(!s.length)return[];const i=[];return s.forEach(n=>{const a=e.namespaces[n].accounts;i.push(...a)}),i}function he(t){return Object.fromEntries(Object.entries(t).filter(([e,s])=>{var i,n;return((i=s?.chains)==null?void 0:i.length)&&((n=s?.chains)==null?void 0:n.length)>0}))}function A(t={},e={}){const s=he(le(t)),i=he(le(e));return at(s,i)}function le(t){var e,s,i,n,a;const r={};if(!h.isValidObject(t))return r;for(const[c,o]of Object.entries(t)){const l=h.isCaipNamespace(c)?[c]:o.chains,u=o.methods||[],p=o.events||[],m=o.rpcMap||{},d=h.parseNamespaceKey(c);r[d]=ut($($({},r[d]),o),{chains:h.mergeArrays(l,(e=r[d])==null?void 0:e.chains),methods:h.mergeArrays(u,(s=r[d])==null?void 0:s.methods),events:h.mergeArrays(p,(i=r[d])==null?void 0:i.events)}),(h.isValidObject(m)||h.isValidObject(((n=r[d])==null?void 0:n.rpcMap)||{}))&&(r[d].rpcMap=$($({},m),(a=r[d])==null?void 0:a.rpcMap))}return r}function ue(t){return t.includes(":")?t.split(":")[2]:t}function de(t){const e={};for(const[s,i]of Object.entries(t)){const n=i.methods||[],a=i.events||[],r=i.accounts||[],c=h.isCaipNamespace(s)?[s]:i.chains?i.chains:pe(i.accounts);e[s]={chains:c,methods:n,events:a,accounts:r}}return e}function x(t){return typeof t=="number"?t:t.includes("0x")?parseInt(t,16):(t=t.includes(":")?t.split(":")[1]:t,isNaN(Number(t))?t:Number(t))}function mt(t){try{const e=JSON.parse(t);return typeof e=="object"&&e!==null&&!Array.isArray(e)}catch{return!1}}const fe={},b=t=>fe[t],F=(t,e)=>{fe[t]=e};var gt=Object.defineProperty,me=Object.getOwnPropertySymbols,yt=Object.prototype.hasOwnProperty,vt=Object.prototype.propertyIsEnumerable,ge=(t,e,s)=>e in t?gt(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,ye=(t,e)=>{for(var s in e||(e={}))yt.call(e,s)&&ge(t,s,e[s]);if(me)for(var s of me(e))vt.call(e,s)&&ge(t,s,e[s]);return t};const ve="eip155",wt=["atomic","flow-control","paymasterService","sessionKeys","auxiliaryFunds"],bt=t=>t&&t.startsWith("0x")?BigInt(t).toString(10):t,U=t=>t&&t.startsWith("0x")?t:`0x${BigInt(t).toString(16)}`,we=t=>Object.keys(t).filter(e=>wt.includes(e)).reduce((e,s)=>(e[s]=Pt(t[s]),e),{}),Pt=t=>typeof t=="string"&&mt(t)?JSON.parse(t):t,Ot=(t,e,s)=>{const{sessionProperties:i={},scopedProperties:n={}}=t,a={};if(!h.isValidObject(n)&&!h.isValidObject(i))return;const r=we(i);for(const c of s){const o=bt(c);if(!o)continue;a[U(o)]=r;const l=n?.[`${ve}:${o}`];if(l){const u=l?.[`${ve}:${o}:${e}`];a[U(o)]=ye(ye({},a[U(o)]),we(u||l))}}for(const[c,o]of Object.entries(a))Object.keys(o).length===0&&delete a[c];return Object.keys(a).length>0?a:void 0};var It=Object.defineProperty,St=(t,e,s)=>e in t?It(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,$t=(t,e,s)=>St(t,typeof e!="symbol"?e+"":e,s);let H;class V{constructor(e){$t(this,"storage"),this.storage=e}async getItem(e){return await this.storage.getItem(e)}async setItem(e,s){return await this.storage.setItem(e,s)}async removeItem(e){return await this.storage.removeItem(e)}static getStorage(e){return H||(H=new V(e)),H}}var At=Object.defineProperty,Et=Object.defineProperties,jt=Object.getOwnPropertyDescriptors,be=Object.getOwnPropertySymbols,Ct=Object.prototype.hasOwnProperty,Nt=Object.prototype.propertyIsEnumerable,Pe=(t,e,s)=>e in t?At(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,qt=(t,e)=>{for(var s in e||(e={}))Ct.call(e,s)&&Pe(t,s,e[s]);if(be)for(var s of be(e))Nt.call(e,s)&&Pe(t,s,e[s]);return t},_t=(t,e)=>Et(t,jt(e));async function Rt(t,e){const s=h.parseChainId(t.result.capabilities.caip345.caip2),i=t.result.capabilities.caip345.transactionHashes,n=await Promise.allSettled(i.map(p=>Dt(s.reference,p,e))),a=n.filter(p=>p.status==="fulfilled").map(p=>p.value).filter(p=>p);n.filter(p=>p.status==="rejected").forEach(p=>console.warn("Failed to fetch transaction receipt:",p.reason));const r=!a.length||a.some(p=>!p),c=a.every(p=>p?.status==="0x1"),o=a.every(p=>p?.status==="0x0"),l=a.some(p=>p?.status==="0x0");let u;return r?u=100:c?u=200:o?u=500:l&&(u=600),{id:t.result.id,version:t.request.version,atomic:t.request.atomicRequired,chainId:t.request.chainId,capabilities:t.result.capabilities,receipts:a,status:u}}async function Dt(t,e,s){return await s(parseInt(t)).request(N.formatJsonRpcRequest("eth_getTransactionReceipt",[e]))}async function xt({sendCalls:t,storage:e}){const s=await e.getItem(v);await e.setItem(v,_t(qt({},s),{[t.result.id]:{request:t.request,result:t.result,expiry:h.calcExpiry(Re)}}))}async function Ft({resultId:t,storage:e}){const s=await e.getItem(v);if(s){delete s[t],await e.setItem(v,s);for(const i in s)h.isExpired(s[i].expiry)&&delete s[i];await e.setItem(v,s)}}async function Ut({resultId:t,storage:e}){const s=await e.getItem(v),i=s?.[t];if(i&&!h.isExpired(i.expiry))return i;await Ft({resultId:t,storage:e})}var Ht=Object.defineProperty,Lt=Object.defineProperties,Bt=Object.getOwnPropertyDescriptors,Oe=Object.getOwnPropertySymbols,Mt=Object.prototype.hasOwnProperty,Kt=Object.prototype.propertyIsEnumerable,L=(t,e,s)=>e in t?Ht(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,B=(t,e)=>{for(var s in e||(e={}))Mt.call(e,s)&&L(t,s,e[s]);if(Oe)for(var s of Oe(e))Kt.call(e,s)&&L(t,s,e[s]);return t},M=(t,e)=>Lt(t,Bt(e)),y=(t,e,s)=>L(t,typeof e!="symbol"?e+"":e,s);class Vt{constructor(e){y(this,"name","eip155"),y(this,"client"),y(this,"chainId"),y(this,"namespace"),y(this,"httpProviders"),y(this,"events"),y(this,"storage"),this.namespace=e.namespace,this.events=b("events"),this.client=b("client"),this.httpProviders=this.createHttpProviders(),this.chainId=parseInt(this.getDefaultChain()),this.storage=V.getStorage(this.client.core.storage)}async request(e){switch(e.request.method){case"eth_requestAccounts":return this.getAccounts();case"eth_accounts":return this.getAccounts();case"wallet_switchEthereumChain":return await this.handleSwitchChain(e);case"eth_chainId":return parseInt(this.getDefaultChain());case"wallet_getCapabilities":return await this.getCapabilities(e);case"wallet_getCallsStatus":return await this.getCallStatus(e);case"wallet_sendCalls":return await this.sendCalls(e)}return this.namespace.methods.includes(e.request.method)?await this.client.request(e):this.getHttpProvider().request(e.request)}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}setDefaultChain(e,s){this.httpProviders[e]||this.setHttpProvider(parseInt(e),s);const i=this.chainId;this.chainId=parseInt(e),this.events.emit(_.DEFAULT_CHAIN_CHANGED,{currentCaipChainId:`${this.name}:${e}`,previousCaipChainId:`${this.name}:${i}`})}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId.toString();if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}createHttpProvider(e,s){const i=s||oe(`${this.name}:${e}`,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new W.JsonRpcProvider(new J.HttpConnection(i,b("disableProviderPing")))}setHttpProvider(e,s){const i=this.createHttpProvider(e,s);i&&(this.httpProviders[e]=i)}createHttpProviders(){const e={};return this.namespace.chains.forEach(s=>{var i;const n=parseInt(dt(s));e[n]=this.createHttpProvider(n,(i=this.namespace.rpcMap)==null?void 0:i[s])}),e}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(s=>s.split(":")[1]===this.chainId.toString()).map(s=>s.split(":")[2]))]:[]}getHttpProvider(e){const s=e||this.chainId;return this.httpProviders[s]||(this.httpProviders=M(B({},this.httpProviders),{[s]:this.createHttpProvider(s)}),this.httpProviders[s])}async handleSwitchChain(e){var s,i;let n=e.request.params?(s=e.request.params[0])==null?void 0:s.chainId:"0x0";n=n.startsWith("0x")?n:`0x${n}`;const a=parseInt(n,16);if(this.isChainApproved(a))this.setDefaultChain(`${a}`);else if(this.namespace.methods.includes("wallet_switchEthereumChain"))await this.client.request({topic:e.topic,request:{method:e.request.method,params:[{chainId:n}]},chainId:(i=this.namespace.chains)==null?void 0:i[0]}),this.setDefaultChain(`${a}`);else throw new Error(`Failed to switch to chain 'eip155:${a}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);return null}isChainApproved(e){return this.namespace.chains.includes(`${this.name}:${e}`)}async getCapabilities(e){var s,i,n,a,r;const c=(i=(s=e.request)==null?void 0:s.params)==null?void 0:i[0],o=((a=(n=e.request)==null?void 0:n.params)==null?void 0:a[1])||[];if(!c)throw new Error("Missing address parameter in `wallet_getCapabilities` request");const l=this.client.session.get(e.topic),u=((r=l?.sessionProperties)==null?void 0:r.capabilities)||{},p=`${c}${o.join(",")}`,m=u?.[p];if(m)return m;let d;try{d=Ot(l,c,o)}catch(C){console.warn("Failed to extract capabilities from session",C)}if(d)return d;const z=await this.client.request(e);try{await this.client.session.update(e.topic,{sessionProperties:M(B({},l.sessionProperties||{}),{capabilities:M(B({},u||{}),{[p]:z})})})}catch(C){console.warn("Failed to update session with capabilities",C)}return z}async getCallStatus(e){var s,i,n;const a=this.client.session.get(e.topic),r=(s=a.sessionProperties)==null?void 0:s.bundler_name;if(r){const l=this.getBundlerUrl(e.chainId,r);try{return await this.getUserOperationReceipt(l,e)}catch(u){console.warn("Failed to fetch call status from bundler",u,l)}}const c=(i=a.sessionProperties)==null?void 0:i.bundler_url;if(c)try{return await this.getUserOperationReceipt(c,e)}catch(l){console.warn("Failed to fetch call status from custom bundler",l,c)}const o=await Ut({resultId:(n=e.request.params)==null?void 0:n[0],storage:this.storage});if(o)try{return await Rt(o,this.getHttpProvider.bind(this))}catch(l){console.warn("Failed to fetch call status from stored send calls",l,o)}if(this.namespace.methods.includes(e.request.method))return await this.client.request(e);throw new Error("Fetching call status not approved by the wallet.")}async getUserOperationReceipt(e,s){var i;const n=new URL(e),a=await fetch(n,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(N.formatJsonRpcRequest("eth_getUserOperationReceipt",[(i=s.request.params)==null?void 0:i[0]]))});if(!a.ok)throw new Error(`Failed to fetch user operation receipt - ${a.status}`);return await a.json()}getBundlerUrl(e,s){return`${_e}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${s}`}async sendCalls(e){var s,i,n;const a=await this.client.request(e),r=(s=e.request.params)==null?void 0:s[0],c=a?.id,o=a?.capabilities||{},l=(i=o?.caip345)==null?void 0:i.caip2,u=(n=o?.caip345)==null?void 0:n.transactionHashes;return!c||!l||!(u!=null&&u.length)||await xt({sendCalls:{request:r,result:a},storage:this.storage}),a}}var zt=Object.defineProperty,Gt=(t,e,s)=>e in t?zt(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,P=(t,e,s)=>Gt(t,typeof e!="symbol"?e+"":e,s);class Wt{constructor(e){P(this,"name",k),P(this,"client"),P(this,"httpProviders"),P(this,"events"),P(this,"namespace"),P(this,"chainId"),this.namespace=e.namespace,this.events=b("events"),this.client=b("client"),this.chainId=this.getDefaultChain(),this.name=this.getNamespaceName(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace.chains=[...new Set((this.namespace.chains||[]).concat(e.chains||[]))],this.namespace.accounts=[...new Set((this.namespace.accounts||[]).concat(e.accounts||[]))],this.namespace.methods=[...new Set((this.namespace.methods||[]).concat(e.methods||[]))],this.namespace.events=[...new Set((this.namespace.events||[]).concat(e.events||[]))],this.httpProviders=this.createHttpProviders()}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider(e.chainId).request(e.request)}setDefaultChain(e,s){this.httpProviders[e]||this.setHttpProvider(e,s);const i=this.chainId;this.chainId=e,this.events.emit(_.DEFAULT_CHAIN_CHANGED,{currentCaipChainId:`${this.name}:${e}`,previousCaipChainId:`${this.name}:${i}`})}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getNamespaceName(){const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return h.parseChainId(e).namespace}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(s=>s.split(":")[1]===this.chainId.toString()).map(s=>s.split(":")[2]))]:[]}createHttpProviders(){var e,s;const i={};return(s=(e=this.namespace)==null?void 0:e.accounts)==null||s.forEach(n=>{var a,r;const c=h.parseChainId(n),o=(r=(a=this.namespace)==null?void 0:a.rpcMap)==null?void 0:r[`${c.namespace}:${c.reference}`];i[c.reference]=this.createHttpProvider(n,o)}),i}getHttpProvider(e){const s=h.parseChainId(e).reference,i=this.httpProviders[s];if(typeof i>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return i}setHttpProvider(e,s){const i=this.createHttpProvider(e,s);i&&(this.httpProviders[e]=i)}createHttpProvider(e,s){const i=s||oe(e,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new W.JsonRpcProvider(new Ee.default(i,b("disableProviderPing")))}}var Jt=Object.defineProperty,Yt=Object.defineProperties,Xt=Object.getOwnPropertyDescriptors,Ie=Object.getOwnPropertySymbols,kt=Object.prototype.hasOwnProperty,Qt=Object.prototype.propertyIsEnumerable,K=(t,e,s)=>e in t?Jt(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,O=(t,e)=>{for(var s in e||(e={}))kt.call(e,s)&&K(t,s,e[s]);if(Ie)for(var s of Ie(e))Qt.call(e,s)&&K(t,s,e[s]);return t},E=(t,e)=>Yt(t,Xt(e)),f=(t,e,s)=>K(t,typeof e!="symbol"?e+"":e,s);class j{constructor(e){f(this,"client"),f(this,"namespaces"),f(this,"optionalNamespaces"),f(this,"sessionProperties"),f(this,"scopedProperties"),f(this,"events",new je.default),f(this,"rpcProviders",{}),f(this,"session"),f(this,"providerOpts"),f(this,"logger"),f(this,"uri"),f(this,"disableProviderPing",!1),this.providerOpts=e,this.logger=typeof e?.logger<"u"&&typeof e?.logger!="string"?e.logger:G.pino(G.getDefaultLoggerOptions({level:e?.logger||Y})),this.disableProviderPing=e?.disableProviderPing||!1}static async init(e){const s=new j(e);return await s.initialize(),s}async request(e,s,i){const[n,a]=this.validateChain(s);if(!this.session)throw new Error("Please call connect() before request()");return await this.getProvider(n).request({request:O({},e),chainId:`${n}:${a}`,topic:this.session.topic,expiry:i})}sendAsync(e,s,i,n){const a=new Date().getTime();this.request(e,i,n).then(r=>s(null,N.formatJsonRpcResult(a,r))).catch(r=>s(r,void 0))}async enable(){if(!this.client)throw new Error("Sign Client not initialized");return this.session||await this.connect({namespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties,scopedProperties:this.scopedProperties}),await this.requestAccounts()}async disconnect(){var e;if(!this.session)throw new Error("Please call connect() before enable()");await this.client.disconnect({topic:(e=this.session)==null?void 0:e.topic,reason:h.getSdkError("USER_DISCONNECTED")}),await this.cleanup()}async connect(e){if(!this.client)throw new Error("Sign Client not initialized");if(this.setNamespaces(e),this.cleanupPendingPairings(),!e.skipPairing)return await this.pair(e.pairingTopic)}async authenticate(e,s){if(!this.client)throw new Error("Sign Client not initialized");this.setNamespaces(e),await this.cleanupPendingPairings();const{uri:i,response:n}=await this.client.authenticate(e,s);i&&(this.uri=i,this.events.emit("display_uri",i));const a=await n();if(this.session=a.session,this.session){const r=de(this.session.namespaces);this.namespaces=A(this.namespaces,r),await this.persist("namespaces",this.namespaces),this.onConnect()}return a}on(e,s){this.events.on(e,s)}once(e,s){this.events.once(e,s)}removeListener(e,s){this.events.removeListener(e,s)}off(e,s){this.events.off(e,s)}get isWalletConnect(){return!0}async pair(e){const{uri:s,approval:i}=await this.client.connect({pairingTopic:e,requiredNamespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties,scopedProperties:this.scopedProperties});s&&(this.uri=s,this.events.emit("display_uri",s));const n=await i();this.session=n;const a=de(n.namespaces);return this.namespaces=A(this.namespaces,a),await this.persist("namespaces",this.namespaces),await this.persist("optionalNamespaces",this.optionalNamespaces),this.onConnect(),this.session}setDefaultChain(e,s){try{if(!this.session)return;const[i,n]=this.validateChain(e);this.getProvider(i).setDefaultChain(n,s)}catch(i){if(!/Please call connect/.test(i.message))throw i}}async cleanupPendingPairings(e={}){try{this.logger.info("Cleaning up inactive pairings...");const s=this.client.pairing.getAll();if(!h.isValidArray(s))return;for(const i of s)e.deletePairings?this.client.core.expirer.set(i.topic,0):await this.client.core.relayer.subscriber.unsubscribe(i.topic);this.logger.info(`Inactive pairings cleared: ${s.length}`)}catch(s){this.logger.warn("Failed to cleanup pending pairings",s)}}abortPairingAttempt(){this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.")}async checkStorage(){this.namespaces=await this.getFromStore("namespaces")||{},this.optionalNamespaces=await this.getFromStore("optionalNamespaces")||{},this.session&&this.createProviders()}async initialize(){this.logger.trace("Initialized"),await this.createClient(),await this.checkStorage(),this.registerEventListeners()}async createClient(){var e,s;if(this.client=this.providerOpts.client||await Ae.default.init({core:this.providerOpts.core,logger:this.providerOpts.logger||Y,relayUrl:this.providerOpts.relayUrl||Ce,projectId:this.providerOpts.projectId,metadata:this.providerOpts.metadata,storageOptions:this.providerOpts.storageOptions,storage:this.providerOpts.storage,name:this.providerOpts.name,customStoragePrefix:this.providerOpts.customStoragePrefix,telemetryEnabled:this.providerOpts.telemetryEnabled}),this.providerOpts.session)try{this.session=this.client.session.get(this.providerOpts.session.topic)}catch(i){throw this.logger.error("Failed to get session",i),new Error(`The provided session: ${(s=(e=this.providerOpts)==null?void 0:e.session)==null?void 0:s.topic} doesn't exist in the Sign client`)}else{const i=this.client.session.getAll();this.session=i[0]}this.logger.trace("SignClient Initialized")}createProviders(){if(!this.client)throw new Error("Sign Client not initialized");if(!this.session)throw new Error("Session not initialized. Please call connect() before enable()");const e=[...new Set(Object.keys(this.session.namespaces).map(s=>h.parseNamespaceKey(s)))];F("client",this.client),F("events",this.events),F("disableProviderPing",this.disableProviderPing),e.forEach(s=>{if(!this.session)return;const i=ft(s,this.session);if(i?.length===0)return;const n=pe(i),a=A(this.namespaces,this.optionalNamespaces),r=E(O({},a[s]),{accounts:i,chains:n});switch(s){case"eip155":this.rpcProviders[s]=new Vt({namespace:r});break;default:this.rpcProviders[s]=new Wt({namespace:r})}})}registerEventListeners(){if(typeof this.client>"u")throw new Error("Sign Client is not initialized");this.client.on("session_ping",e=>{var s;const{topic:i}=e;i===((s=this.session)==null?void 0:s.topic)&&this.events.emit("session_ping",e)}),this.client.on("session_event",e=>{var s;const{params:i,topic:n}=e;if(n!==((s=this.session)==null?void 0:s.topic))return;const{event:a}=i;if(a.name==="accountsChanged"){const r=a.data;r&&h.isValidArray(r)&&this.events.emit("accountsChanged",r.map(ue))}else if(a.name==="chainChanged"){const r=i.chainId,c=i.event.data,o=h.parseNamespaceKey(r),l=x(r)!==x(c)?`${o}:${x(c)}`:r;this.onChainChanged({currentCaipChainId:l})}else this.events.emit(a.name,a.data);this.events.emit("session_event",e)}),this.client.on("session_update",({topic:e,params:s})=>{var i,n;if(e!==((i=this.session)==null?void 0:i.topic))return;const{namespaces:a}=s,r=(n=this.client)==null?void 0:n.session.get(e);this.session=E(O({},r),{namespaces:a}),this.onSessionUpdate(),this.events.emit("session_update",{topic:e,params:s})}),this.client.on("session_delete",async e=>{var s;e.topic===((s=this.session)==null?void 0:s.topic)&&(await this.cleanup(),this.events.emit("session_delete",e),this.events.emit("disconnect",E(O({},h.getSdkError("USER_DISCONNECTED")),{data:e.topic})))}),this.on(_.DEFAULT_CHAIN_CHANGED,e=>{this.onChainChanged(E(O({},e),{internal:!0}))})}getProvider(e){return this.rpcProviders[e]||this.rpcProviders[k]}onSessionUpdate(){Object.keys(this.rpcProviders).forEach(e=>{var s;this.getProvider(e).updateNamespace((s=this.session)==null?void 0:s.namespaces[e])})}setNamespaces(e){const{namespaces:s={},optionalNamespaces:i={},sessionProperties:n,scopedProperties:a}=e;this.optionalNamespaces=A(s,i),this.sessionProperties=n,this.scopedProperties=a}validateChain(e){const[s,i]=e?.split(":")||["",""];if(!this.namespaces||!Object.keys(this.namespaces).length)return[s,i];if(s&&!Object.keys(this.namespaces||{}).map(r=>h.parseNamespaceKey(r)).includes(s))throw new Error(`Namespace '${s}' is not configured. Please call connect() first with namespace config.`);if(s&&i)return[s,i];const n=h.parseNamespaceKey(Object.keys(this.namespaces)[0]),a=this.rpcProviders[n].getDefaultChain();return[n,a]}async requestAccounts(){const[e]=this.validateChain();return await this.getProvider(e).requestAccounts()}async onChainChanged({currentCaipChainId:e,previousCaipChainId:s,internal:i=!1}){if(!this.namespaces)return;const[n,a]=this.validateChain(e);a&&(this.updateNamespaceChain(n,a),i?(this.events.emit("chainChanged",a),this.emitAccountsChangedOnChainChange({namespace:n,currentCaipChainId:e,previousCaipChainId:s})):this.getProvider(n).setDefaultChain(a),await this.persist("namespaces",this.namespaces))}emitAccountsChangedOnChainChange({namespace:e,currentCaipChainId:s,previousCaipChainId:i}){var n,a;try{if(i===s)return;const r=(a=(n=this.session)==null?void 0:n.namespaces[e])==null?void 0:a.accounts;if(!r)return;const c=r.filter(o=>o.includes(`${s}:`)).map(ue);if(!h.isValidArray(c))return;this.events.emit("accountsChanged",c)}catch(r){this.logger.warn("Failed to emit accountsChanged on chain change",r)}}updateNamespaceChain(e,s){if(!this.namespaces)return;const i=this.namespaces[e]?e:`${e}:${s}`,n={chains:[],methods:[],events:[],defaultChain:s};this.namespaces[i]?this.namespaces[i]&&(this.namespaces[i].defaultChain=s):this.namespaces[i]=n}onConnect(){this.createProviders(),this.events.emit("connect",{session:this.session})}async cleanup(){this.namespaces=void 0,this.optionalNamespaces=void 0,this.sessionProperties=void 0,await this.deleteFromStore("namespaces"),await this.deleteFromStore("optionalNamespaces"),await this.deleteFromStore("sessionProperties"),this.session=void 0,this.cleanupPendingPairings({deletePairings:!0}),await this.cleanupStorage()}async persist(e,s){var i;const n=((i=this.session)==null?void 0:i.topic)||"";await this.client.core.storage.setItem(`${I}/${e}${n}`,s)}async getFromStore(e){var s;const i=((s=this.session)==null?void 0:s.topic)||"";return await this.client.core.storage.getItem(`${I}/${e}${i}`)}async deleteFromStore(e){var s;const i=((s=this.session)==null?void 0:s.topic)||"";await this.client.core.storage.removeItem(`${I}/${e}${i}`)}async cleanupStorage(){var e;try{if(((e=this.client)==null?void 0:e.session.length)>0)return;const s=await this.client.core.storage.getKeys();for(const i of s)i.startsWith(I)&&await this.client.core.storage.removeItem(i)}catch(s){this.logger.warn("Failed to cleanup storage",s)}}}const Zt=j;exports.UniversalProvider=Zt,exports.default=j;
//# sourceMappingURL=index.cjs.js.map
