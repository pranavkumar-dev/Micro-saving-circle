import je from"@walletconnect/sign-client";import{isValidObject as P,isCaipNamespace as V,parseNamespaceKey as O,mergeArrays as q,parseChainId as I,calcExpiry as Ce,isExpired as Y,getSdkError as X,isValidArray as R}from"@walletconnect/utils";import{pino as Ne,getDefaultLoggerOptions as De}from"@walletconnect/logger";import{formatJsonRpcRequest as k,formatJsonRpcResult as qe}from"@walletconnect/jsonrpc-utils";import{JsonRpcProvider as Q}from"@walletconnect/jsonrpc-provider";import Re,{HttpConnection as _e}from"@walletconnect/jsonrpc-http-connection";import xe from"events";const Z="error",Fe="wss://relay.walletconnect.org",He="wc",Ue="universal_provider",$=`${He}@2:${Ue}:`,T="https://rpc.walletconnect.org/v1/",ee="generic",Be=`${T}bundler`,y="call_status",Le=86400,_={DEFAULT_CHAIN_CHANGED:"default_chain_changed"};function x(t){return t==null||typeof t!="object"&&typeof t!="function"}function te(t){return Object.getOwnPropertySymbols(t).filter(e=>Object.prototype.propertyIsEnumerable.call(t,e))}function se(t){return t==null?t===void 0?"[object Undefined]":"[object Null]":Object.prototype.toString.call(t)}const Me="[object RegExp]",ie="[object String]",ne="[object Number]",re="[object Boolean]",ae="[object Arguments]",ze="[object Symbol]",Ge="[object Date]",We="[object Map]",Je="[object Set]",Ke="[object Array]",Ve="[object ArrayBuffer]",Ye="[object Object]",Xe="[object DataView]",ke="[object Uint8Array]",Qe="[object Uint8ClampedArray]",Ze="[object Uint16Array]",Te="[object Uint32Array]",et="[object Int8Array]",tt="[object Int16Array]",st="[object Int32Array]",it="[object Float32Array]",nt="[object Float64Array]";function F(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)}function rt(t,e){return v(t,void 0,t,new Map,e)}function v(t,e,s,i=new Map,r=void 0){const a=r?.(t,e,s,i);if(a!=null)return a;if(x(t))return t;if(i.has(t))return i.get(t);if(Array.isArray(t)){const n=new Array(t.length);i.set(t,n);for(let c=0;c<t.length;c++)n[c]=v(t[c],c,s,i,r);return Object.hasOwn(t,"index")&&(n.index=t.index),Object.hasOwn(t,"input")&&(n.input=t.input),n}if(t instanceof Date)return new Date(t.getTime());if(t instanceof RegExp){const n=new RegExp(t.source,t.flags);return n.lastIndex=t.lastIndex,n}if(t instanceof Map){const n=new Map;i.set(t,n);for(const[c,o]of t)n.set(c,v(o,c,s,i,r));return n}if(t instanceof Set){const n=new Set;i.set(t,n);for(const c of t)n.add(v(c,void 0,s,i,r));return n}if(typeof Buffer<"u"&&Buffer.isBuffer(t))return t.subarray();if(F(t)){const n=new(Object.getPrototypeOf(t)).constructor(t.length);i.set(t,n);for(let c=0;c<t.length;c++)n[c]=v(t[c],c,s,i,r);return n}if(t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer)return t.slice(0);if(t instanceof DataView){const n=new DataView(t.buffer.slice(0),t.byteOffset,t.byteLength);return i.set(t,n),m(n,t,s,i,r),n}if(typeof File<"u"&&t instanceof File){const n=new File([t],t.name,{type:t.type});return i.set(t,n),m(n,t,s,i,r),n}if(t instanceof Blob){const n=new Blob([t],{type:t.type});return i.set(t,n),m(n,t,s,i,r),n}if(t instanceof Error){const n=new t.constructor;return i.set(t,n),n.message=t.message,n.name=t.name,n.stack=t.stack,n.cause=t.cause,m(n,t,s,i,r),n}if(typeof t=="object"&&at(t)){const n=Object.create(Object.getPrototypeOf(t));return i.set(t,n),m(n,t,s,i,r),n}return t}function m(t,e,s=t,i,r){const a=[...Object.keys(e),...te(e)];for(let n=0;n<a.length;n++){const c=a[n],o=Object.getOwnPropertyDescriptor(t,c);(o==null||o.writable)&&(t[c]=v(e[c],c,s,i,r))}}function at(t){switch(se(t)){case ae:case Ke:case Ve:case Xe:case re:case Ge:case it:case nt:case et:case tt:case st:case We:case ne:case Ye:case Me:case Je:case ie:case ze:case ke:case Qe:case Ze:case Te:return!0;default:return!1}}function ct(t,e){return rt(t,(s,i,r,a)=>{const n=e?.(s,i,r,a);if(n!=null)return n;if(typeof t=="object")switch(Object.prototype.toString.call(t)){case ne:case ie:case re:{const c=new t.constructor(t?.valueOf());return m(c,t),c}case ae:{const c={};return m(c,t),c.length=t.length,c[Symbol.iterator]=t[Symbol.iterator],c}default:return}})}function ce(t){return ct(t)}function oe(t){return t!==null&&typeof t=="object"&&se(t)==="[object Arguments]"}function pe(t){return typeof t=="object"&&t!==null}function ot(){}function pt(t){return F(t)}function ht(t){if(typeof t!="object"||t==null)return!1;if(Object.getPrototypeOf(t)===null)return!0;if(Object.prototype.toString.call(t)!=="[object Object]"){const s=t[Symbol.toStringTag];return s==null||!Object.getOwnPropertyDescriptor(t,Symbol.toStringTag)?.writable?!1:t.toString()===`[object ${s}]`}let e=t;for(;Object.getPrototypeOf(e)!==null;)e=Object.getPrototypeOf(e);return Object.getPrototypeOf(t)===e}function lt(t){if(x(t))return t;if(Array.isArray(t)||F(t)||t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer)return t.slice(0);const e=Object.getPrototypeOf(t),s=e.constructor;if(t instanceof Date||t instanceof Map||t instanceof Set)return new s(t);if(t instanceof RegExp){const i=new s(t);return i.lastIndex=t.lastIndex,i}if(t instanceof DataView)return new s(t.buffer.slice(0));if(t instanceof Error){const i=new s(t.message);return i.stack=t.stack,i.name=t.name,i.cause=t.cause,i}if(typeof File<"u"&&t instanceof File)return new s([t],t.name,{type:t.type,lastModified:t.lastModified});if(typeof t=="object"){const i=Object.create(e);return Object.assign(i,t)}return t}function ut(t,...e){const s=e.slice(0,-1),i=e[e.length-1];let r=t;for(let a=0;a<s.length;a++){const n=s[a];r=A(r,n,i,new Map)}return r}function A(t,e,s,i){if(x(t)&&(t=Object(t)),e==null||typeof e!="object")return t;if(i.has(e))return lt(i.get(e));if(i.set(e,t),Array.isArray(e)){e=e.slice();for(let a=0;a<e.length;a++)e[a]=e[a]??void 0}const r=[...Object.keys(e),...te(e)];for(let a=0;a<r.length;a++){const n=r[a];let c=e[n],o=t[n];if(oe(c)&&(c={...c}),oe(o)&&(o={...o}),typeof Buffer<"u"&&Buffer.isBuffer(c)&&(c=ce(c)),Array.isArray(c))if(typeof o=="object"&&o!=null){const l=[],p=Reflect.ownKeys(o);for(let f=0;f<p.length;f++){const u=p[f];l[u]=o[u]}o=l}else o=[];const h=s(o,c,n,t,e,i);h!=null?t[n]=h:Array.isArray(c)||pe(o)&&pe(c)?t[n]=A(o,c,s,i):o==null&&ht(c)?t[n]=A({},c,s,i):o==null&&pt(c)?t[n]=ce(c):(o===void 0||c!==void 0)&&(t[n]=c)}return t}function dt(t,...e){return ut(t,...e,ot)}var ft=Object.defineProperty,mt=Object.defineProperties,gt=Object.getOwnPropertyDescriptors,he=Object.getOwnPropertySymbols,yt=Object.prototype.hasOwnProperty,vt=Object.prototype.propertyIsEnumerable,le=(t,e,s)=>e in t?ft(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,E=(t,e)=>{for(var s in e||(e={}))yt.call(e,s)&&le(t,s,e[s]);if(he)for(var s of he(e))vt.call(e,s)&&le(t,s,e[s]);return t},wt=(t,e)=>mt(t,gt(e));function ue(t,e,s){var i;const r=I(t);return((i=e.rpcMap)==null?void 0:i[r.reference])||`${T}?chainId=${r.namespace}:${r.reference}&projectId=${s}`}function bt(t){return t.includes(":")?t.split(":")[1]:t}function de(t){return t.map(e=>`${e.split(":")[0]}:${e.split(":")[1]}`)}function Pt(t,e){const s=Object.keys(e.namespaces).filter(r=>r.includes(t));if(!s.length)return[];const i=[];return s.forEach(r=>{const a=e.namespaces[r].accounts;i.push(...a)}),i}function fe(t){return Object.fromEntries(Object.entries(t).filter(([e,s])=>{var i,r;return((i=s?.chains)==null?void 0:i.length)&&((r=s?.chains)==null?void 0:r.length)>0}))}function j(t={},e={}){const s=fe(me(t)),i=fe(me(e));return dt(s,i)}function me(t){var e,s,i,r,a;const n={};if(!P(t))return n;for(const[c,o]of Object.entries(t)){const h=V(c)?[c]:o.chains,l=o.methods||[],p=o.events||[],f=o.rpcMap||{},u=O(c);n[u]=wt(E(E({},n[u]),o),{chains:q(h,(e=n[u])==null?void 0:e.chains),methods:q(l,(s=n[u])==null?void 0:s.methods),events:q(p,(i=n[u])==null?void 0:i.events)}),(P(f)||P(((r=n[u])==null?void 0:r.rpcMap)||{}))&&(n[u].rpcMap=E(E({},f),(a=n[u])==null?void 0:a.rpcMap))}return n}function ge(t){return t.includes(":")?t.split(":")[2]:t}function ye(t){const e={};for(const[s,i]of Object.entries(t)){const r=i.methods||[],a=i.events||[],n=i.accounts||[],c=V(s)?[s]:i.chains?i.chains:de(i.accounts);e[s]={chains:c,methods:r,events:a,accounts:n}}return e}function H(t){return typeof t=="number"?t:t.includes("0x")?parseInt(t,16):(t=t.includes(":")?t.split(":")[1]:t,isNaN(Number(t))?t:Number(t))}function Ot(t){try{const e=JSON.parse(t);return typeof e=="object"&&e!==null&&!Array.isArray(e)}catch{return!1}}const ve={},w=t=>ve[t],U=(t,e)=>{ve[t]=e};var It=Object.defineProperty,we=Object.getOwnPropertySymbols,St=Object.prototype.hasOwnProperty,$t=Object.prototype.propertyIsEnumerable,be=(t,e,s)=>e in t?It(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,Pe=(t,e)=>{for(var s in e||(e={}))St.call(e,s)&&be(t,s,e[s]);if(we)for(var s of we(e))$t.call(e,s)&&be(t,s,e[s]);return t};const Oe="eip155",At=["atomic","flow-control","paymasterService","sessionKeys","auxiliaryFunds"],Et=t=>t&&t.startsWith("0x")?BigInt(t).toString(10):t,B=t=>t&&t.startsWith("0x")?t:`0x${BigInt(t).toString(16)}`,Ie=t=>Object.keys(t).filter(e=>At.includes(e)).reduce((e,s)=>(e[s]=jt(t[s]),e),{}),jt=t=>typeof t=="string"&&Ot(t)?JSON.parse(t):t,Ct=(t,e,s)=>{const{sessionProperties:i={},scopedProperties:r={}}=t,a={};if(!P(r)&&!P(i))return;const n=Ie(i);for(const c of s){const o=Et(c);if(!o)continue;a[B(o)]=n;const h=r?.[`${Oe}:${o}`];if(h){const l=h?.[`${Oe}:${o}:${e}`];a[B(o)]=Pe(Pe({},a[B(o)]),Ie(l||h))}}for(const[c,o]of Object.entries(a))Object.keys(o).length===0&&delete a[c];return Object.keys(a).length>0?a:void 0};var Nt=Object.defineProperty,Dt=(t,e,s)=>e in t?Nt(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,qt=(t,e,s)=>Dt(t,typeof e!="symbol"?e+"":e,s);let L;class J{constructor(e){qt(this,"storage"),this.storage=e}async getItem(e){return await this.storage.getItem(e)}async setItem(e,s){return await this.storage.setItem(e,s)}async removeItem(e){return await this.storage.removeItem(e)}static getStorage(e){return L||(L=new J(e)),L}}var Rt=Object.defineProperty,_t=Object.defineProperties,xt=Object.getOwnPropertyDescriptors,Se=Object.getOwnPropertySymbols,Ft=Object.prototype.hasOwnProperty,Ht=Object.prototype.propertyIsEnumerable,$e=(t,e,s)=>e in t?Rt(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,Ut=(t,e)=>{for(var s in e||(e={}))Ft.call(e,s)&&$e(t,s,e[s]);if(Se)for(var s of Se(e))Ht.call(e,s)&&$e(t,s,e[s]);return t},Bt=(t,e)=>_t(t,xt(e));async function Lt(t,e){const s=I(t.result.capabilities.caip345.caip2),i=t.result.capabilities.caip345.transactionHashes,r=await Promise.allSettled(i.map(p=>Mt(s.reference,p,e))),a=r.filter(p=>p.status==="fulfilled").map(p=>p.value).filter(p=>p);r.filter(p=>p.status==="rejected").forEach(p=>console.warn("Failed to fetch transaction receipt:",p.reason));const n=!a.length||a.some(p=>!p),c=a.every(p=>p?.status==="0x1"),o=a.every(p=>p?.status==="0x0"),h=a.some(p=>p?.status==="0x0");let l;return n?l=100:c?l=200:o?l=500:h&&(l=600),{id:t.result.id,version:t.request.version,atomic:t.request.atomicRequired,chainId:t.request.chainId,capabilities:t.result.capabilities,receipts:a,status:l}}async function Mt(t,e,s){return await s(parseInt(t)).request(k("eth_getTransactionReceipt",[e]))}async function zt({sendCalls:t,storage:e}){const s=await e.getItem(y);await e.setItem(y,Bt(Ut({},s),{[t.result.id]:{request:t.request,result:t.result,expiry:Ce(Le)}}))}async function Gt({resultId:t,storage:e}){const s=await e.getItem(y);if(s){delete s[t],await e.setItem(y,s);for(const i in s)Y(s[i].expiry)&&delete s[i];await e.setItem(y,s)}}async function Wt({resultId:t,storage:e}){const s=await e.getItem(y),i=s?.[t];if(i&&!Y(i.expiry))return i;await Gt({resultId:t,storage:e})}var Jt=Object.defineProperty,Kt=Object.defineProperties,Vt=Object.getOwnPropertyDescriptors,Ae=Object.getOwnPropertySymbols,Yt=Object.prototype.hasOwnProperty,Xt=Object.prototype.propertyIsEnumerable,M=(t,e,s)=>e in t?Jt(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,z=(t,e)=>{for(var s in e||(e={}))Yt.call(e,s)&&M(t,s,e[s]);if(Ae)for(var s of Ae(e))Xt.call(e,s)&&M(t,s,e[s]);return t},G=(t,e)=>Kt(t,Vt(e)),g=(t,e,s)=>M(t,typeof e!="symbol"?e+"":e,s);class kt{constructor(e){g(this,"name","eip155"),g(this,"client"),g(this,"chainId"),g(this,"namespace"),g(this,"httpProviders"),g(this,"events"),g(this,"storage"),this.namespace=e.namespace,this.events=w("events"),this.client=w("client"),this.httpProviders=this.createHttpProviders(),this.chainId=parseInt(this.getDefaultChain()),this.storage=J.getStorage(this.client.core.storage)}async request(e){switch(e.request.method){case"eth_requestAccounts":return this.getAccounts();case"eth_accounts":return this.getAccounts();case"wallet_switchEthereumChain":return await this.handleSwitchChain(e);case"eth_chainId":return parseInt(this.getDefaultChain());case"wallet_getCapabilities":return await this.getCapabilities(e);case"wallet_getCallsStatus":return await this.getCallStatus(e);case"wallet_sendCalls":return await this.sendCalls(e)}return this.namespace.methods.includes(e.request.method)?await this.client.request(e):this.getHttpProvider().request(e.request)}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}setDefaultChain(e,s){this.httpProviders[e]||this.setHttpProvider(parseInt(e),s);const i=this.chainId;this.chainId=parseInt(e),this.events.emit(_.DEFAULT_CHAIN_CHANGED,{currentCaipChainId:`${this.name}:${e}`,previousCaipChainId:`${this.name}:${i}`})}requestAccounts(){return this.getAccounts()}getDefaultChain(){if(this.chainId)return this.chainId.toString();if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}createHttpProvider(e,s){const i=s||ue(`${this.name}:${e}`,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new Q(new _e(i,w("disableProviderPing")))}setHttpProvider(e,s){const i=this.createHttpProvider(e,s);i&&(this.httpProviders[e]=i)}createHttpProviders(){const e={};return this.namespace.chains.forEach(s=>{var i;const r=parseInt(bt(s));e[r]=this.createHttpProvider(r,(i=this.namespace.rpcMap)==null?void 0:i[s])}),e}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(s=>s.split(":")[1]===this.chainId.toString()).map(s=>s.split(":")[2]))]:[]}getHttpProvider(e){const s=e||this.chainId;return this.httpProviders[s]||(this.httpProviders=G(z({},this.httpProviders),{[s]:this.createHttpProvider(s)}),this.httpProviders[s])}async handleSwitchChain(e){var s,i;let r=e.request.params?(s=e.request.params[0])==null?void 0:s.chainId:"0x0";r=r.startsWith("0x")?r:`0x${r}`;const a=parseInt(r,16);if(this.isChainApproved(a))this.setDefaultChain(`${a}`);else if(this.namespace.methods.includes("wallet_switchEthereumChain"))await this.client.request({topic:e.topic,request:{method:e.request.method,params:[{chainId:r}]},chainId:(i=this.namespace.chains)==null?void 0:i[0]}),this.setDefaultChain(`${a}`);else throw new Error(`Failed to switch to chain 'eip155:${a}'. The chain is not approved or the wallet does not support 'wallet_switchEthereumChain' method.`);return null}isChainApproved(e){return this.namespace.chains.includes(`${this.name}:${e}`)}async getCapabilities(e){var s,i,r,a,n;const c=(i=(s=e.request)==null?void 0:s.params)==null?void 0:i[0],o=((a=(r=e.request)==null?void 0:r.params)==null?void 0:a[1])||[];if(!c)throw new Error("Missing address parameter in `wallet_getCapabilities` request");const h=this.client.session.get(e.topic),l=((n=h?.sessionProperties)==null?void 0:n.capabilities)||{},p=`${c}${o.join(",")}`,f=l?.[p];if(f)return f;let u;try{u=Ct(h,c,o)}catch(D){console.warn("Failed to extract capabilities from session",D)}if(u)return u;const K=await this.client.request(e);try{await this.client.session.update(e.topic,{sessionProperties:G(z({},h.sessionProperties||{}),{capabilities:G(z({},l||{}),{[p]:K})})})}catch(D){console.warn("Failed to update session with capabilities",D)}return K}async getCallStatus(e){var s,i,r;const a=this.client.session.get(e.topic),n=(s=a.sessionProperties)==null?void 0:s.bundler_name;if(n){const h=this.getBundlerUrl(e.chainId,n);try{return await this.getUserOperationReceipt(h,e)}catch(l){console.warn("Failed to fetch call status from bundler",l,h)}}const c=(i=a.sessionProperties)==null?void 0:i.bundler_url;if(c)try{return await this.getUserOperationReceipt(c,e)}catch(h){console.warn("Failed to fetch call status from custom bundler",h,c)}const o=await Wt({resultId:(r=e.request.params)==null?void 0:r[0],storage:this.storage});if(o)try{return await Lt(o,this.getHttpProvider.bind(this))}catch(h){console.warn("Failed to fetch call status from stored send calls",h,o)}if(this.namespace.methods.includes(e.request.method))return await this.client.request(e);throw new Error("Fetching call status not approved by the wallet.")}async getUserOperationReceipt(e,s){var i;const r=new URL(e),a=await fetch(r,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(k("eth_getUserOperationReceipt",[(i=s.request.params)==null?void 0:i[0]]))});if(!a.ok)throw new Error(`Failed to fetch user operation receipt - ${a.status}`);return await a.json()}getBundlerUrl(e,s){return`${Be}?projectId=${this.client.core.projectId}&chainId=${e}&bundler=${s}`}async sendCalls(e){var s,i,r;const a=await this.client.request(e),n=(s=e.request.params)==null?void 0:s[0],c=a?.id,o=a?.capabilities||{},h=(i=o?.caip345)==null?void 0:i.caip2,l=(r=o?.caip345)==null?void 0:r.transactionHashes;return!c||!h||!(l!=null&&l.length)||await zt({sendCalls:{request:n,result:a},storage:this.storage}),a}}var Qt=Object.defineProperty,Zt=(t,e,s)=>e in t?Qt(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,b=(t,e,s)=>Zt(t,typeof e!="symbol"?e+"":e,s);class Tt{constructor(e){b(this,"name",ee),b(this,"client"),b(this,"httpProviders"),b(this,"events"),b(this,"namespace"),b(this,"chainId"),this.namespace=e.namespace,this.events=w("events"),this.client=w("client"),this.chainId=this.getDefaultChain(),this.name=this.getNamespaceName(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace.chains=[...new Set((this.namespace.chains||[]).concat(e.chains||[]))],this.namespace.accounts=[...new Set((this.namespace.accounts||[]).concat(e.accounts||[]))],this.namespace.methods=[...new Set((this.namespace.methods||[]).concat(e.methods||[]))],this.namespace.events=[...new Set((this.namespace.events||[]).concat(e.events||[]))],this.httpProviders=this.createHttpProviders()}requestAccounts(){return this.getAccounts()}request(e){return this.namespace.methods.includes(e.request.method)?this.client.request(e):this.getHttpProvider(e.chainId).request(e.request)}setDefaultChain(e,s){this.httpProviders[e]||this.setHttpProvider(e,s);const i=this.chainId;this.chainId=e,this.events.emit(_.DEFAULT_CHAIN_CHANGED,{currentCaipChainId:`${this.name}:${e}`,previousCaipChainId:`${this.name}:${i}`})}getDefaultChain(){if(this.chainId)return this.chainId;if(this.namespace.defaultChain)return this.namespace.defaultChain;const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return e.split(":")[1]}getNamespaceName(){const e=this.namespace.chains[0];if(!e)throw new Error("ChainId not found");return I(e).namespace}getAccounts(){const e=this.namespace.accounts;return e?[...new Set(e.filter(s=>s.split(":")[1]===this.chainId.toString()).map(s=>s.split(":")[2]))]:[]}createHttpProviders(){var e,s;const i={};return(s=(e=this.namespace)==null?void 0:e.accounts)==null||s.forEach(r=>{var a,n;const c=I(r),o=(n=(a=this.namespace)==null?void 0:a.rpcMap)==null?void 0:n[`${c.namespace}:${c.reference}`];i[c.reference]=this.createHttpProvider(r,o)}),i}getHttpProvider(e){const s=I(e).reference,i=this.httpProviders[s];if(typeof i>"u")throw new Error(`JSON-RPC provider for ${e} not found`);return i}setHttpProvider(e,s){const i=this.createHttpProvider(e,s);i&&(this.httpProviders[e]=i)}createHttpProvider(e,s){const i=s||ue(e,this.namespace,this.client.core.projectId);if(!i)throw new Error(`No RPC url provided for chainId: ${e}`);return new Q(new Re(i,w("disableProviderPing")))}}var es=Object.defineProperty,ts=Object.defineProperties,ss=Object.getOwnPropertyDescriptors,Ee=Object.getOwnPropertySymbols,is=Object.prototype.hasOwnProperty,ns=Object.prototype.propertyIsEnumerable,W=(t,e,s)=>e in t?es(t,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):t[e]=s,S=(t,e)=>{for(var s in e||(e={}))is.call(e,s)&&W(t,s,e[s]);if(Ee)for(var s of Ee(e))ns.call(e,s)&&W(t,s,e[s]);return t},C=(t,e)=>ts(t,ss(e)),d=(t,e,s)=>W(t,typeof e!="symbol"?e+"":e,s);class N{constructor(e){d(this,"client"),d(this,"namespaces"),d(this,"optionalNamespaces"),d(this,"sessionProperties"),d(this,"scopedProperties"),d(this,"events",new xe),d(this,"rpcProviders",{}),d(this,"session"),d(this,"providerOpts"),d(this,"logger"),d(this,"uri"),d(this,"disableProviderPing",!1),this.providerOpts=e,this.logger=typeof e?.logger<"u"&&typeof e?.logger!="string"?e.logger:Ne(De({level:e?.logger||Z})),this.disableProviderPing=e?.disableProviderPing||!1}static async init(e){const s=new N(e);return await s.initialize(),s}async request(e,s,i){const[r,a]=this.validateChain(s);if(!this.session)throw new Error("Please call connect() before request()");return await this.getProvider(r).request({request:S({},e),chainId:`${r}:${a}`,topic:this.session.topic,expiry:i})}sendAsync(e,s,i,r){const a=new Date().getTime();this.request(e,i,r).then(n=>s(null,qe(a,n))).catch(n=>s(n,void 0))}async enable(){if(!this.client)throw new Error("Sign Client not initialized");return this.session||await this.connect({namespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties,scopedProperties:this.scopedProperties}),await this.requestAccounts()}async disconnect(){var e;if(!this.session)throw new Error("Please call connect() before enable()");await this.client.disconnect({topic:(e=this.session)==null?void 0:e.topic,reason:X("USER_DISCONNECTED")}),await this.cleanup()}async connect(e){if(!this.client)throw new Error("Sign Client not initialized");if(this.setNamespaces(e),this.cleanupPendingPairings(),!e.skipPairing)return await this.pair(e.pairingTopic)}async authenticate(e,s){if(!this.client)throw new Error("Sign Client not initialized");this.setNamespaces(e),await this.cleanupPendingPairings();const{uri:i,response:r}=await this.client.authenticate(e,s);i&&(this.uri=i,this.events.emit("display_uri",i));const a=await r();if(this.session=a.session,this.session){const n=ye(this.session.namespaces);this.namespaces=j(this.namespaces,n),await this.persist("namespaces",this.namespaces),this.onConnect()}return a}on(e,s){this.events.on(e,s)}once(e,s){this.events.once(e,s)}removeListener(e,s){this.events.removeListener(e,s)}off(e,s){this.events.off(e,s)}get isWalletConnect(){return!0}async pair(e){const{uri:s,approval:i}=await this.client.connect({pairingTopic:e,requiredNamespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties,scopedProperties:this.scopedProperties});s&&(this.uri=s,this.events.emit("display_uri",s));const r=await i();this.session=r;const a=ye(r.namespaces);return this.namespaces=j(this.namespaces,a),await this.persist("namespaces",this.namespaces),await this.persist("optionalNamespaces",this.optionalNamespaces),this.onConnect(),this.session}setDefaultChain(e,s){try{if(!this.session)return;const[i,r]=this.validateChain(e);this.getProvider(i).setDefaultChain(r,s)}catch(i){if(!/Please call connect/.test(i.message))throw i}}async cleanupPendingPairings(e={}){try{this.logger.info("Cleaning up inactive pairings...");const s=this.client.pairing.getAll();if(!R(s))return;for(const i of s)e.deletePairings?this.client.core.expirer.set(i.topic,0):await this.client.core.relayer.subscriber.unsubscribe(i.topic);this.logger.info(`Inactive pairings cleared: ${s.length}`)}catch(s){this.logger.warn("Failed to cleanup pending pairings",s)}}abortPairingAttempt(){this.logger.warn("abortPairingAttempt is deprecated. This is now a no-op.")}async checkStorage(){this.namespaces=await this.getFromStore("namespaces")||{},this.optionalNamespaces=await this.getFromStore("optionalNamespaces")||{},this.session&&this.createProviders()}async initialize(){this.logger.trace("Initialized"),await this.createClient(),await this.checkStorage(),this.registerEventListeners()}async createClient(){var e,s;if(this.client=this.providerOpts.client||await je.init({core:this.providerOpts.core,logger:this.providerOpts.logger||Z,relayUrl:this.providerOpts.relayUrl||Fe,projectId:this.providerOpts.projectId,metadata:this.providerOpts.metadata,storageOptions:this.providerOpts.storageOptions,storage:this.providerOpts.storage,name:this.providerOpts.name,customStoragePrefix:this.providerOpts.customStoragePrefix,telemetryEnabled:this.providerOpts.telemetryEnabled}),this.providerOpts.session)try{this.session=this.client.session.get(this.providerOpts.session.topic)}catch(i){throw this.logger.error("Failed to get session",i),new Error(`The provided session: ${(s=(e=this.providerOpts)==null?void 0:e.session)==null?void 0:s.topic} doesn't exist in the Sign client`)}else{const i=this.client.session.getAll();this.session=i[0]}this.logger.trace("SignClient Initialized")}createProviders(){if(!this.client)throw new Error("Sign Client not initialized");if(!this.session)throw new Error("Session not initialized. Please call connect() before enable()");const e=[...new Set(Object.keys(this.session.namespaces).map(s=>O(s)))];U("client",this.client),U("events",this.events),U("disableProviderPing",this.disableProviderPing),e.forEach(s=>{if(!this.session)return;const i=Pt(s,this.session);if(i?.length===0)return;const r=de(i),a=j(this.namespaces,this.optionalNamespaces),n=C(S({},a[s]),{accounts:i,chains:r});switch(s){case"eip155":this.rpcProviders[s]=new kt({namespace:n});break;default:this.rpcProviders[s]=new Tt({namespace:n})}})}registerEventListeners(){if(typeof this.client>"u")throw new Error("Sign Client is not initialized");this.client.on("session_ping",e=>{var s;const{topic:i}=e;i===((s=this.session)==null?void 0:s.topic)&&this.events.emit("session_ping",e)}),this.client.on("session_event",e=>{var s;const{params:i,topic:r}=e;if(r!==((s=this.session)==null?void 0:s.topic))return;const{event:a}=i;if(a.name==="accountsChanged"){const n=a.data;n&&R(n)&&this.events.emit("accountsChanged",n.map(ge))}else if(a.name==="chainChanged"){const n=i.chainId,c=i.event.data,o=O(n),h=H(n)!==H(c)?`${o}:${H(c)}`:n;this.onChainChanged({currentCaipChainId:h})}else this.events.emit(a.name,a.data);this.events.emit("session_event",e)}),this.client.on("session_update",({topic:e,params:s})=>{var i,r;if(e!==((i=this.session)==null?void 0:i.topic))return;const{namespaces:a}=s,n=(r=this.client)==null?void 0:r.session.get(e);this.session=C(S({},n),{namespaces:a}),this.onSessionUpdate(),this.events.emit("session_update",{topic:e,params:s})}),this.client.on("session_delete",async e=>{var s;e.topic===((s=this.session)==null?void 0:s.topic)&&(await this.cleanup(),this.events.emit("session_delete",e),this.events.emit("disconnect",C(S({},X("USER_DISCONNECTED")),{data:e.topic})))}),this.on(_.DEFAULT_CHAIN_CHANGED,e=>{this.onChainChanged(C(S({},e),{internal:!0}))})}getProvider(e){return this.rpcProviders[e]||this.rpcProviders[ee]}onSessionUpdate(){Object.keys(this.rpcProviders).forEach(e=>{var s;this.getProvider(e).updateNamespace((s=this.session)==null?void 0:s.namespaces[e])})}setNamespaces(e){const{namespaces:s={},optionalNamespaces:i={},sessionProperties:r,scopedProperties:a}=e;this.optionalNamespaces=j(s,i),this.sessionProperties=r,this.scopedProperties=a}validateChain(e){const[s,i]=e?.split(":")||["",""];if(!this.namespaces||!Object.keys(this.namespaces).length)return[s,i];if(s&&!Object.keys(this.namespaces||{}).map(n=>O(n)).includes(s))throw new Error(`Namespace '${s}' is not configured. Please call connect() first with namespace config.`);if(s&&i)return[s,i];const r=O(Object.keys(this.namespaces)[0]),a=this.rpcProviders[r].getDefaultChain();return[r,a]}async requestAccounts(){const[e]=this.validateChain();return await this.getProvider(e).requestAccounts()}async onChainChanged({currentCaipChainId:e,previousCaipChainId:s,internal:i=!1}){if(!this.namespaces)return;const[r,a]=this.validateChain(e);a&&(this.updateNamespaceChain(r,a),i?(this.events.emit("chainChanged",a),this.emitAccountsChangedOnChainChange({namespace:r,currentCaipChainId:e,previousCaipChainId:s})):this.getProvider(r).setDefaultChain(a),await this.persist("namespaces",this.namespaces))}emitAccountsChangedOnChainChange({namespace:e,currentCaipChainId:s,previousCaipChainId:i}){var r,a;try{if(i===s)return;const n=(a=(r=this.session)==null?void 0:r.namespaces[e])==null?void 0:a.accounts;if(!n)return;const c=n.filter(o=>o.includes(`${s}:`)).map(ge);if(!R(c))return;this.events.emit("accountsChanged",c)}catch(n){this.logger.warn("Failed to emit accountsChanged on chain change",n)}}updateNamespaceChain(e,s){if(!this.namespaces)return;const i=this.namespaces[e]?e:`${e}:${s}`,r={chains:[],methods:[],events:[],defaultChain:s};this.namespaces[i]?this.namespaces[i]&&(this.namespaces[i].defaultChain=s):this.namespaces[i]=r}onConnect(){this.createProviders(),this.events.emit("connect",{session:this.session})}async cleanup(){this.namespaces=void 0,this.optionalNamespaces=void 0,this.sessionProperties=void 0,await this.deleteFromStore("namespaces"),await this.deleteFromStore("optionalNamespaces"),await this.deleteFromStore("sessionProperties"),this.session=void 0,this.cleanupPendingPairings({deletePairings:!0}),await this.cleanupStorage()}async persist(e,s){var i;const r=((i=this.session)==null?void 0:i.topic)||"";await this.client.core.storage.setItem(`${$}/${e}${r}`,s)}async getFromStore(e){var s;const i=((s=this.session)==null?void 0:s.topic)||"";return await this.client.core.storage.getItem(`${$}/${e}${i}`)}async deleteFromStore(e){var s;const i=((s=this.session)==null?void 0:s.topic)||"";await this.client.core.storage.removeItem(`${$}/${e}${i}`)}async cleanupStorage(){var e;try{if(((e=this.client)==null?void 0:e.session.length)>0)return;const s=await this.client.core.storage.getKeys();for(const i of s)i.startsWith($)&&await this.client.core.storage.removeItem(i)}catch(s){this.logger.warn("Failed to cleanup storage",s)}}}const rs=N;export{rs as UniversalProvider,N as default};
//# sourceMappingURL=index.es.js.map
